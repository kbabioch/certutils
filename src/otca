#! /bin/bash

# otca
#
# Copyright (c) 2015 Karol Babioch <karol@babioch.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Version string
VERSION="1"

# Various exit codes used throughout the program
EXIT_INVALID_OPTION=1
EXIT_NO_TMPDIR=2
EXIT_OPENSSL_ERROR=3

# Name of the server if not set explicitly
SERVERNAME=$(hostname)

# Name of the client, empty by default
CLIENTNAME=""

# Number of bits of the key(s)
BITS="2048"

# Number of years certificate should be valid for
YEARS="5"

# Default OpenSSL config file
CONFFILE="/etc/otca/otca.cnf"

# Name of output directory
OUTDIR=""

# Flag for PKCS12 mode
PKCS12="NO"

# Flag for verbose output
VERBOSE="NO"

# Output a prefixed error message and exit with given code
# $1: Exit code
# $2: Error message (optional)
error()
{

    if [[ ! -z "$2" ]]; then

        echo "ERROR: $2" >&2

    fi

    exit $1

}

# Output usage help
help()
{

    cat << EOF

    Usage: $0 [OPTIONS...] CLIENTNAME

    OPTIONS:

      -s, --servername=         Set name of the server explicitly, rather than using the hostname of the machine

      -c, --config=             Location of OpenSSL configuration file

      -b, --bits=               Number of bits of the RSA keys, 2048 by default
      -y, --years=              Number of years certificates should be valid for, 3 by default

      -p, --pkcs12              Create PKCS12 files instead of PEM keys and certificates
      -d, --dir=                Name of output directory, "$SERVERNAME+$CLIENTNAME" by default

      -v, --verbose             Enable verbose output

      -h, --help                Show this usage help
          --version             Show version information

    CLIENTNAME: Name of the client that the OTCA should be set up for

EOF

}

# Output version information
version()
{

    cat << EOF

    Version: $VERSION

    Copyright (c) 2015 Karol Babioch <karol@babioch.de>

    This program comes with ABSOLUTELY NO WARRANTY; This is free software, and
    you are welcome to redistribute it under certain conditions;

EOF

}

# Output information about OTCA configuration to user
info()
{

    cat << EOF

    One-Time CA for

        Server:     $SERVERNAME
        Client:     $CLIENTNAME

        Config:     $CONFFILE

        Bits:       $BITS
        Years:      $YEARS

        PKCS12:     $PKCS12
        Output dir: $OUTDIR

        Verbose:    $VERBOSE
        Tempdir:    $TMPDIR

EOF

}

# Returns hex string with given length
# $1: Requested string length
random_hex()
{

    # 2 hex bytes needed for representation of a single byte -> /2
    openssl rand -hex $(($1/2))

}

# Writes random serial to given file
#
# According to RFC5280 serial might be up to 20 octets long, so this is what
# we use here.
randomize_serial()
{

    random_hex 20 > serial

}

# Sets up the OTCA
#
# This initializes the OTCA. It creates a CSR, self-signs it and creates the
# environment that is needed by OpenSSL's ca(1) utility.
init_otca()
{

    # Create necessary files and directories (required by OpenSSL's ca(1))
    touch database serial
    mkdir -p certs csr keys pkcs12

    # Create CSR for OTCA itself
    openssl req \
        -newkey rsa:"$BITS" \
        -keyout "keys/otca.key" \
        -nodes \
        -config "$CONFFILE" \
        -subj "/CN=OTCA $SERVERNAME+$CLIENTNAME" \
        -out "csr/otca.csr" \
        -batch \
        > /dev/null 2>&1

    # Randomize serial
    randomize_serial

    # Self-sign OTCA
    openssl ca \
        -config "$CONFFILE" \
        -selfsign \
        -keyfile keys/otca.key \
        -name otca_ca \
        -extensions otca_ext_ca \
        -in csr/otca.csr \
        -startdate $(date "+%y%m%d000000Z") \
        -enddate $(date "+%y%m%d000000Z" -d "+ $YEARS years") \
        -out certs/otca.pem \
        -batch \
        > /dev/null 2>&1

}

# Create a CSR for entity with given common name
#
#$1: commonName (CN)
create_csr()
{

    # Create CSR
    openssl req \
        -newkey rsa:"$BITS" \
        -keyout "keys/$1.key" \
        -nodes \
        -config "$CONFFILE" \
        -subj "/CN=$1" \
        -out "csr/$1.csr" \
        -batch \
        > /dev/null 2>&1

}

# Sign a CSR with CAs private key
#
#$1: name
#$2: extensions
sign_csr()
{

    # Randomize serial
    randomize_serial

    # Sign CSR
    openssl ca \
        -config "$CONFFILE" \
        -keyfile keys/otca.key \
        -cert certs/otca.pem \
        -name otca_ca \
        -extensions "$2" \
        -in "csr/$1.csr" \
        -startdate $(date "+%y%m%d000000Z") \
        -enddate $(date "+%y%m%d000000Z" -d "+ $YEARS years") \
        -out "certs/$1.pem" \
        -batch \
        > /dev/null 2>&1

}

# Create PKCS12 from private key and certificate
#
#$1: name
create_pkcs12()
{

    # Create PKCS12 file
    openssl pkcs12 \
        -export \
        -out "pkcs12/$1.p12" \
        -passout pass: \
        -inkey "keys/$1.key" \
        -in "certs/$1.pem" \
        -certfile certs/otca.pem \
        > /dev/null 2>&1

}

# Various clean up tasks performend whenever the script is exited
cleanup()
{

    # Change back to original working directory
    popd > /dev/null 2>&1

    # Remove temporary scratch space
    rm -r "$TMPDIR" 2> /dev/null

}

# Execute cleanup function for particular signals
trap cleanup SIGINT SIGQUIT SIGTERM EXIT

# Parse options provided as command line arguments
for i in "$@"
do

    case "$i" in

        # Set name of server (short)
        -s)
            SERVERNAME="$2"
            shift 2
            ;;

        # Set name of server (long)
        --servername=*)
            SERVERNAME="${i#*=}"
            shift
            ;;

        # OpenSSL configuration file (short)
        -c)
            CONFFILE="$2"
            shift 2
            ;;

        # OpenSSL configuration file (long)
        --config=*)
            CONFFILE="${i#*=}"
            shift
            ;;

        # Set number of bits (short)
        -b)
            BITS="$2"
            shift 2
            ;;

        # Set number of bits (long)
        --bits=*)
            BITS="${i#*=}"
            shift
            ;;

        # Set number of years (short)
        -y)
            YEARS="$2"
            shift 2
            ;;

        # Set number of years (long)
        --years=*)
            YEARS="${i#*=}"
            shift
            ;;

        # Enable PKCS12 mode (short & long)
        -p|--pkcs12)
            PKCS12="YES"
            shift
            ;;

        # Set output directory (short)
        -d)
            OUTDIR="$2"
            shift 2
            ;;

        # Set output directory (long)
        --dir=*)
            OUTDIR="${i#*=}"
            shift
            ;;

        # Enable verbose mode (short & long)
        -v|--verbose)
            VERBOSE="YES"
            shift
            ;;

        # Usage help
        -h|--help)
            help
            exit
            ;;

        # Version information
        --version)
            version
            exit
            ;;

    esac

done

# Check for correct number of arguments
if [[ "$#" != 1 ]]; then

    error $EXIT_INVALID_OPTION "Wrong number of arguments!"

fi

# Check for empty servername
if [[ -z "$SERVERNAME" ]]; then

    error $EXIT_INVALID_OPTION "Servername must not be empty!"

fi

# Check for empty clientname
if [[ -z "$1" ]]; then

    error $EXIT_INVALID_OPTION "Clientname must not be empty!"

fi

# Clientname was provided as command line argument
CLIENTNAME="$1"

# Check if servername is different from clientname
if [[ "$SERVERNAME" == "$CLIENTNAME" ]]; then

    error $EXIT_INVALID_OPTION "Servername and clientname must be different!"

fi

# Check for empty bits
if [[ -z "$BITS" ]]; then

    error $EXIT_INVALID_OPTION "Empty number of bits!"

fi

# Check for empty years
if [[ -z "$YEARS" ]]; then

    error $EXIT_INVALID_OPTION "Empty number of years!"

fi

# Check if OpenSSL configuration file exists
if [[ ! -f "$CONFFILE" ]]; then

    error $EXIT_INVALID_OPTION "OpenSSL configuration file does not exist!"

fi

# Check if output directory was set
if [[ -z "$OUTDIR" ]]; then

    # Set default value if it was not set explicetely (or is empty)
    OUTDIR="$SERVERNAME+$CLIENTNAME"

fi

# Check if output directory already exists
if [[ -d "$OUTDIR" ]]; then

    error $EXIT_INVALID_OPTION "Output directory already exists!"

fi

# Create temporary scratch space
TMPDIR=$(mktemp -d) || exit $EXIT_NO_TMPDIR

# Output information about configuration
info

# Save current working directory on directory stack and change to TMPDIR
pushd "$TMPDIR" > /dev/null 2>&1

# Initialize CA
init_otca

# Create CSR for server and client
create_csr "$SERVERNAME"
create_csr "$CLIENTNAME"

# Sign CSRs with appropriate extensions
sign_csr "$SERVERNAME" otca_ext_server
sign_csr "$CLIENTNAME" otca_ext_client

# Create PKCS12
if [[ $PKCS12 == "YES" ]]; then

    create_pkcs12 "$SERVERNAME"
    create_pkcs12 "$CLIENTNAME"

fi

# Get back to old working directory
popd > /dev/null 2>&1

# Create output directory
mkdir "$OUTDIR"

# Move relevant files
if [[ $PKCS12 == "YES" ]]; then

    mv "$TMPDIR/pkcs12/$SERVERNAME.p12" "$OUTDIR/"
    mv "$TMPDIR/pkcs12/$CLIENTNAME.p12" "$OUTDIR/"

else

    mv "$TMPDIR/certs/$SERVERNAME.pem" "$OUTDIR/"
    mv "$TMPDIR/keys/$SERVERNAME.key" "$OUTDIR/"

    mv "$TMPDIR/certs/$CLIENTNAME.pem" "$OUTDIR/"
    mv "$TMPDIR/keys/$CLIENTNAME.key" "$OUTDIR/"

    mv "$TMPDIR/certs/otca.pem" "$OUTDIR/"

fi

