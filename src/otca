#! /bin/bash

# otca
#
# Copyright (c) 2015 Karol Babioch <karol@babioch.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Version string
VERSION="1"

# Various exit codes used throughout the program
EXIT_INVALID_OPTIONS=1
EXIT_NO_TMPDIR=2

# Name of the server if not set explicitly
SERVERNAME=$(hostname)

# Name of the client, empty by default
CLIENTNAME=""

# Number of bits of the key(s)
BITS="2048"

# Number of years certificate should be valid for
YEARS="5"

# Default OpenSSL config file
CONFFILE="/etc/otca/otca.cnf"

# Files to be created for OpenSSL ca(1) application
TOUCHFILES="database serial"

# Directory structure to be created within temporary scratch space
CREATEDIRS="certs csr keys"

# Output a prefixed error message and exit with given code
# $1: Exit code
# $2: Error message
error()
{

    echo "ERROR: $2" >&2

    exit $1

}

# Output usage help
help()
{

    cat << EOF

    Usage: $0 [OPTIONS...] CLIENTNAME

    OPTIONS:

      -s, --servername=         Set name of the server explicitly, rather than using the hostname of the machine

      -c, --config=             Location of OpenSSL configuration file

      -b, --bits=               Number of bits of the RSA keys, 2048 by default
      -y, --years=              Number of years certificates should be valid for, 3 by default

      -h, --help                Show this usage help
          --version             Show version information

    CLIENTNAME: Name of the client that the OTCA should be set up for

EOF

}

# Output version information
version()
{

    cat << EOF

    Version: $VERSION

    Copyright (c) 2015 Karol Babioch <karol@babioch.de>

    This program comes with ABSOLUTELY NO WARRANTY; This is free software, and
    you are welcome to redistribute it under certain conditions;

EOF

}

# Output information about OTCA configuration to user
info()
{

    cat << EOF

    One-Time CA for

        Server:     $SERVERNAME
        Client:     $CLIENTNAME

        Config:     $CONFFILE
        Bits:       $BITS
        Years:      $YEARS
        Tempdir:    $TMPDIR

EOF

}

# Returns hex string with given length
# $1: Requested string length
random_hex()
{

    # 2 hex bytes needed for representation of a single byte -> /2
    openssl rand -hex $(($1/2))

}

# Writes random serial to given file
#
# According to RFC5280 serial might be up to 20 octets long, so this is what
# we use here.
randomize_serial()
{

    random_hex 20 > serial

}

# Various clean up tasks performend whenever the script is exited
cleanup()
{

    # Change back to original working directory
    popd > /dev/null 2>&1

    # Remove temporary scratch space
    #rm -r "$TMPDIR" 2> /dev/null

}

# Execute cleanup function for particular signals
trap cleanup SIGINT SIGQUIT SIGTERM EXIT

# Parse options provided as command line arguments
for i in "$@"
do

    case "$i" in

        # Set name of server (short)
        -s)
            SERVERNAME="$2"
            shift 2
            ;;

        # Set name of server (long)
        --servername=*)
            SERVERNAME="${i#*=}"
            shift
            ;;

        # OpenSSL configuration file (short)
        -c)
            CONFFILE="$2"
            shift 2
            ;;

        # OpenSSL configuration file (long)
        --config=*)
            CONFFILE="${i#*=}"
            shift
            ;;

        # Set number of bits (short)
        -b)
            BITS="$2"
            shift 2
            ;;

        # Set number of bits (long)
        --bits=*)
            BITS="${i#*=}"
            shift
            ;;

        # Set number of years (short)
        -y)
            YEARS="$2"
            shift 2
            ;;

        # Set number of years (long)
        --years=*)
            YEARS="${i#*=}"
            shift
            ;;

        # Usage help
        -h|--help)
            help
            exit
            ;;

        # Version information
        --version)
            version
            exit
            ;;

    esac

done

# Check for correct number of arguments
if [[ "$#" != 1 ]]; then

    error $EXIT_INVALID_OPTIONS "Wrong number of arguments!"

fi

# Check for empty servername
if [[ -z "$SERVERNAME" ]]; then

    error $EXIT_INVALID_OPTIONS "Servername must not be empty!"

fi

# Check for empty clientname
if [[ -z "$1" ]]; then

    error $EXIT_INVALID_OPTIONS "Clientname must not be empty!"

fi

# Clientname was provided as command line argument
CLIENTNAME="$1"

# Check for empty bits
if [[ -z "$BITS" ]]; then

    error $EXIT_INVALID_OPTIONS "Empty number of bits!"

fi

# Check for empty years
if [[ -z "$YEARS" ]]; then

    error $EXIT_INVALID_OPTIONS "Empty number of years!"

fi

# Check if OpenSSL configuration file exists
if [[ ! -f "$CONFFILE" ]]; then

    error $EXIT_INVALID_OPTIONS "OpenSSL configuration file does not exist!"

fi

# Create temporary scratch space
TMPDIR=$(mktemp -d) || exit $EXIT_NO_TMPDIR

# Output information to user
info

# Save current working directory on directory stack and change to TMPDIR
pushd "$TMPDIR" > /dev/null 2>&1

# Create necessary files and directories
touch $TOUCHFILES
mkdir $CREATEDIRS

#$1: name
#$2: extensions
sign_csr()
{

    # Randomize serial
    randomize_serial

    # Sign CSR
    openssl ca \
        -config "$CONFFILE" \
        -keyfile keys/otca.key \
        -cert certs/otca.pem \
        -name otca_ca \
        -extensions "$2" \
        -in "csr/$1.csr" \
        -startdate $(date "+%y%m%d000000Z") \
        -enddate $(date "+%y%m%d000000Z" -d "+ $YEARS years") \
        -out "certs/$1.pem" \
        -batch \
        > /dev/null 2>&1

}

#$1: CN
create_csr()
{

    # Create CSR
    openssl req \
        -newkey rsa:"$BITS" \
        -keyout "keys/$1.key" \
        -nodes \
        -config "$CONFFILE" \
        -subj "/CN=$1" \
        -out "csr/$1.csr" \
        -batch \
        > /dev/null 2>&1

}

# Create CSR
openssl req \
    -newkey rsa:"$BITS" \
    -keyout "keys/otca.key" \
    -nodes \
    -config "$CONFFILE" \
    -subj "/CN=OTCA $SERVERNAME+$CLIENTNAME" \
    -out "csr/otca.csr" \
    -batch \
    > /dev/null 2>&1

# Randomize serial
randomize_serial

# Self-sign OTCA
openssl ca \
    -config "$CONFFILE" \
    -selfsign \
    -keyfile keys/otca.key \
    -name otca_ca \
    -extensions otca_ext_ca \
    -in csr/otca.csr \
    -startdate $(date "+%y%m%d000000Z") \
    -enddate $(date "+%y%m%d000000Z" -d "+ $YEARS years") \
    -out certs/otca.pem \
    -batch \
    > /dev/null 2>&1

# Create CSR for server and client
create_csr "$SERVERNAME"
create_csr "$CLIENTNAME"

# Sign CSRs
sign_csr "$SERVERNAME" otca_ext_server
sign_csr "$CLIENTNAME" otca_ext_client

